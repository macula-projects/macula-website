<!doctype html><html lang=zh-cn class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.111.3"><link rel=canonical type=text/html href=/docs/v3.1/chapter5/><link rel=alternate type=application/rss+xml href=/docs/v3.1/chapter5/index.xml><meta name=robots content="noindex, nofollow"><link rel=icon href=/favicons/favicon.ico><title>第五章 | Macula</title><meta name=description content="本章介绍技术标准"><meta property="og:title" content="第五章"><meta property="og:description" content="本章介绍技术标准"><meta property="og:type" content="website"><meta property="og:url" content="/docs/v3.1/chapter5/"><meta property="og:site_name" content="Macula"><meta itemprop=name content="第五章"><meta itemprop=description content="本章介绍技术标准"><meta name=twitter:card content="summary"><meta name=twitter:title content="第五章"><meta name=twitter:description content="本章介绍技术标准"><link rel=preload href=/scss/main.min.56f91794193debaacc9fed9f3ea1305973c18c460520344068f08ae5f95e5027.css as=style><link href=/scss/main.min.56f91794193debaacc9fed9f3ea1305973c18c460520344068f08ae5f95e5027.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-00000000-0"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-00000000-0")}</script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><img src=/img/logo.png></span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/><span>首页</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/project><span>项目</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs><span>文档</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog><span>博客</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=http://14.22.2.220:80/#/login target=_blank><span>体验版</span></a></li></ul></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/docs/v3.1/chapter5/>返回本页常规视图</a>.</p></div><h1 class=title>第五章</h1><div class=lead>本章介绍技术标准</div><ul><li>1: <a href=#pg-91b8d90a03dbd27d194d0b6b82a4b7c2>Java代码规范</a></li><li>2: <a href=#pg-ae15f1e6c3b69f707742b42f78364f30>代码审计规范</a></li><li>3: <a href=#pg-f177d6661903b35e70eb7021d809ac4c>单元测试标准</a></li><li>4: <a href=#pg-eea527f62b505e0c6454198db00db210>第三方包使用标准</a></li><li>5: <a href=#pg-f576067bb623bddf831b63a80c458235>新技术引入标准</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-91b8d90a03dbd27d194d0b6b82a4b7c2>1 - Java代码规范</h1><div class=lead>本文介绍Java代码规范</div><p>说明：本规范分为不同的级别，默认级别为必须遵循级别，而(II)为建议级别，非强制执行。</p><h2 id=格式与命名规范formating-and-naming-conventions>格式与命名规范(Formating and Naming Conventions)</h2><ol><li><p>最重要:不用死记硬背，直接使用Eclipse的自动格式化功能。</p></li><li><p>换行:每行120字符以上&ndash;因为现在屏幕已大为宽广。</p></li><li><p>括号:if,for,while语句全部使用括号包围。</p></li><li><p>命名规则:</p><ul><li>不允许使用汉语拼音命名 避免使用下划线(静态变量除外)</li><li>接口尽量采用"able", &ldquo;ible&rdquo;, or &ldquo;er&rdquo;，如Runnable命名</li><li>尽量不采用首字母为I或加上IF后缀的命名方式，如IBookDao,BookDaoIF。(II)</li></ul></li></ol><h2 id=注释规范document-convertions>注释规范(Document Convertions)</h2><ol><li><p>注释类型</p><ul><li>JAVA DOC注释</li></ul><p>/*** &mldr;. **/</p><ul><li>失效代码注释</li></ul><p>由/**&mldr; **/界定，标准的C-Style的注释。专用于注释已失效的代码。</p><ul><li>代码细节注释</li></ul><p>由//界定，专用于注释代码细节。</p><p>注意：即使有多行注释也仍然使用//，以便与用/**/注释的失效代码分开。</p></li><li><p>注释的格式</p><ul><li>注释中的第一个句子要以（英文）句号、问号或者感叹号结束。Javadoc生成工具会将注释中的第一个句子放在方法汇总表和索引中。</li><li>为了在JavaDoc和IDE中能快速链接跳转到相关联的类与方法，尽量多的使用@see xxx.MyClass，@see xx.MyClass#find(String)。</li><li>Class必须以@author声明作者，体现代码责任，通过@since ${date}标记代码最初产生时间，通过@version $$Id: Standard-Code.xml 4930 2014-03-04 09:45:57Z wzp $$记录当前版本信息</li><li>标识(java keyword, class/method/field/argument名，Constants)在注释中第一次出现时以 {@linkxxx.Myclass}注解以便JavaDoc与IDE中可以链接。(II)</li></ul></li><li><p>注释的内容</p><ul><li>可精简的注释内容</li></ul><p>注释中的每一个单词都要有其不可缺少的意义，注释里不写"@param name -名字"这样的废话。</p><p>如果该注释是废话，连同标签删掉它，而不是自动生成一堆空的标签，如空的@param name，空的@return</p><ul><li>推荐的注释内容</li></ul><p>对于调用复杂的API尽量提供代码示例。(II)</p><p>对于已知的Bug需要声明，//TODO 或 //FIXME 声明:未做/有Bug的代码。(II)</p><p>Null规约: 如果方法允许Null作为参数，或者允许返回值为Null，必须在JavaDoc中说明。否则方法的调用者不允许使用Null作为参数，并认为返回值是Null Safe(不会返回NULL)。</p></li></ol><h2 id=编程规范programming-conventions>编程规范(Programming Conventions)</h2><ol><li><p>基本规范</p><ul><li>当API会面对不可知的调用者时，方法需要对输入参数进行校验，如不符合则抛出IllegalArgumentException，建议使用Spring的Assert系列函数。</li><li>因为System.out.println()，e.printStackTrace()仅把信息显示在控制台，因此不允许使用，必须使用logger打印并记录信息。</li><li>在数组中的元素(如String [1])，如果不再使用需要设为NULL，否则会内存泄漏。因此直接用Collections类而不要使用数组。</li><li>在不需要封闭修改的时候，可使用protected 或 private，使用protected可方便子类重载，在遵循Java开闭原则下，尽量使代码可被外部修改程度降低。</li><li>变量，参数和返回值定义尽量基于接口而不是具体实现类，如Map map = new HashMap();</li><li>用Double 而不是Float，因为float会容易出现小数点后N位的误差，对计算结果要求严格的使用BidDecimal。</li><li>尽量使用第三方库而不是自己编写方法。比如集合间的运算操作可通过apache下的CollectionUtils助手类。</li></ul></li><li><p>异常处理</p><ul><li>重新抛出的异常必须保留原来的异常，即throw new NewException(&ldquo;message&rdquo;, e); 而不能写成throw new NewException(&ldquo;message&rdquo;)。</li><li>在所有异常被捕获且没有重新抛出的地方必须写日志，为了避免日志的多重打印，对于自定义的异常信息，在第一次构造异常时打印，在截获该自定义异常时，可直接抛出。</li><li>如果属于正常异常的空异常处理块必须注释说明原因，否则不允许空的catch块。</li></ul></li><li><p>JDK5.0规范</p><ul><li>重载方法必须使用@Override，可避免父类方法改变时导致重载函数失效。</li><li>不需要关心的warning信息用@SuppressWarnings(&ldquo;unused&rdquo;), @SuppressWarnings(&ldquo;unchecked&rdquo;), @SuppressWarnings(&ldquo;serial&rdquo;) 注释。</li></ul></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-ae15f1e6c3b69f707742b42f78364f30>2 - 代码审计规范</h1><div class=lead>本文介绍代码审计规范</div><p>说明：在代码符合基本的代码规范外，在代码提交到版本控制前，需要进行更为严格的代码审计检查。</p><p>下面通过Eclipse IDE下的多个代码检查工具，指定代码必须符合的审计规范。</p><h2 id=maven体系标准>Maven体系标准</h2><p>对项目开发中的模块和项目，其文档结构，必须符合Maven标准，提供标准的pom.xml文件，并可通过Maven命令行执行的打包、测试、运行等。</p><h2 id=eclipse-code-style>Eclipse Code Style</h2><p>在Eclipse开发环境中，导入指定的代码模版，并按照代码模板格式化代码。</p><ul><li><p>Clean Up设置</p><p>通过Eclipse菜单 Window -> Preference -> Java -> Clean Up -> Import</p><p>选择cleanup.xml文件。</p></li><li><p>Code Template设置</p><p>通过Eclipse菜单 Window -> Preference -> Java -> Code Template -> Import</p><p>选择codetemplates.xml文件。</p></li><li><p>Code Formatter设置</p><p>通过Eclipse菜单 Window -> Preference -> Java -> Formatter -> Import</p><p>选择formatter.xml文件。</p></li></ul><h2 id=eclipse-check-style>Eclipse Check Style</h2><p>通过Eclipse的CheckStyle插件，可以更加严格的检查Java代码的规范性。</p><p>在Eclipse -> Windows -> Preference -> checkstyle中导入checkstyle.xml ，进行代码检查。</p><h2 id=eclipse-findbugs>Eclipse FindBugs</h2><p>FindBugs作为一种静态分析工具 ，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。有了静态分析工具，就可以在不实际运行程序的情况对软件进行分析，起到帮助检测程序潜在的编写问题。</p><p>在使用FindBugs检测的结果中，依据错误的等级，不允许出现“严重”级别的错误，并尽可能消除“一般”性错误。</p><h2 id=svn-check-in-规范>SVN Check In 规范</h2><ol><li>绝不要提交没有编译过的代码，如果你不能编译，那别人也不能编译。</li><li>避免提交一个未经测试的代码。</li><li>提交前作一次更新和测试。如果你修改一个代码一段时间后，并在当前工作环境上进行了测试，并准备提交时，可能另外的开发人员同时也提交了他们的变更在同样的目录上。我们要针对升级后的版本进行测试。</li><li>避免垃圾文件提交。 提交前，那些调试文件，中间文件非常容易忘记去除。</li><li>一次提交的代码解决一个缺陷或新任务。当我们提交代码变更到仓库时，最好一次提交一个原子变更。</li><li>公共分支上不要提交不完整的变更。依据变更集作原子提交是非常聪明的做法，如果一次变更分几次提交，那么原子回退这些变更比较困难。</li><li>代码提交必须有本次提交说明，说明可能是开发的功能、解决的Bug等信息。</li></ol><h2 id=junit测试覆盖规范>JUnit测试覆盖规范</h2><p>要求对主要的业务逻辑代码（即Service层），提供详细的JUnit测试，并要求测试覆盖率达到一定的百分比（具体可根据项目制定）。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f177d6661903b35e70eb7021d809ac4c>3 - 单元测试标准</h1><div class=lead>本文介绍单元测试标准</div><p>说明：在Macula开发平台下，单元测试用例使用JUnit编写，使用的JUnit版本为4.8.1以上，即可通过Annotation的方式标识测试用例。</p><p>对单元测试的编写以及使用，在符合代码规范以及审计规范的前提下，针对测试用例，需要遵循一些额外的标准。</p><h2 id=单元测试类命名规范>单元测试类命名规范</h2><ol><li><p>测试类命名规范</p><p>测试类的命名规则为被测试的类名+Test，其测试类应放在src/test/java目录下，其包名为被测试包下建立的test子包。</p><p>对于一些模块的测试，也在在模块下创建模块级的test子包，并将测试类放入该子包中。</p></li><li><p>测试用例命名规范</p><p>测试用例的命名规则为test+用例方法名称，比如要测试的方法命名为findUserByName，那么测试用例的命名则为testFindUserByName，
其命名规则符合Java方法的命名规则。</p><p>对测试用例，需要加入@Test注解，用来标识该方法为一个测试用例。</p></li><li><p>其他命名规范</p><p>对单元测试类中，编写的辅助性属性或方法，遵循Java开发的命名规则。</p></li></ol><h2 id=单元测试数据规范>单元测试数据规范</h2><p>在单元测试中使用的数据，需要具有典型性和边界性等多种数据的测试。</p><p>当前系统绝大多数为基于数据库系统的管理系统，在数据的准备上，如果能使用HSQL等内存式数据库的情况下，尽量使用内存式数据库，同时在测试用例的@Before和@After标注的方法中，初始化数据和销毁数据。</p><p>在构建所测试数据较为复杂的情况下，可使用公用的实体测试数据库，但需要遵循下列原则：</p><ol><li>其测试用例必须能保证可重复运行均能通过。</li><li>测试用例尽量标识在测试结束后回滚事务，以确保测试用例不会真实修改数据库数据。</li><li>对不能实现事务回滚或因测试需要改变数据库数据的，尽量在单元测试完成后，通过@After等手段，恢复修改的数据到原始状态。</li><li>对无法实现事务回滚且不能恢复到原始状态的数据，其测试导致的数据变化不影响其他测试用例。</li><li>对测试变化后的数据，需要在测试代码中校验是否符合预期，而不是通过查看数据库的方式校验。</li></ol><h2 id=单元测试最小化原则>单元测试最小化原则</h2><p>单元测试其重复执行的频率较大，特别是在项目持续集成情况下，单元将会多次执行。为了加快单元测试速度，以及其他相关类对本单元测试的影响，单元测试需要遵循最小化原则。</p><ol><li>单元测试使用的Spring容器可单独编写，可以只载入本测试用例用到的Bean实例。</li><li>单元测试的测试用例粒度尽可能小，以增强单元测试的强度。</li><li>对于简单的Java类，不需要编写意义不大的测试用例。</li><li>单元测试应具备一定的典型性、边界性等，但如果编写一个完善的单元测试超出了业务需要，可根据业务实际情况选择单元测试数据。</li><li>不可人为为了通过单元测试，而特意构造数据。</li></ol><h2 id=单元测试粒度>单元测试粒度</h2><p>为了在单元测试覆盖率与项目进度、测试用例复杂度之间平衡，对单元测试的粒度做如下规定：</p><ol><li>服务层的public方法必须编写单元测试，protected和private方法可不编写测试用例。</li><li>复杂的存取层需要单独编写测试用例，而不得借用服务层的间接测试的办法。</li><li>对工具类、助手类要编写严格的单元测试，因其使用面广，其测试数据范围需要加大。</li><li>对简单的值对象、简单的get/set方法，不需要提供测试用例。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-eea527f62b505e0c6454198db00db210>4 - 第三方包使用标准</h1><div class=lead>本文介绍第三方包使用标准</div><p>说明：在Macula平台的开发中，已经使用了一些第三方开发包，对于这些包的名称和版本都在Maven的pom.xml中有严格的定义。对于需要修改和调整第三方包的情况，需要遵循如下标准。</p><h2 id=版本更替标准>版本更替标准</h2><p>第三方包在项目的开发和维护期，会因为Bug修复、功能提升、性能提升、架构变化等多种原因，会进行版本的升级。但项目中是否需要跟随最新的第三方包的更新，需要按实际情况考虑。</p><ol><li>原则上不允许由高版本变更为低版本。</li><li>对版本的小版本号更新（比如由3.1.0升级到3.1.1），由于小版本一般为Bug修复、性能提高是产生，在保证升级后不影响编译出错的情况下，备案后允许升级。</li><li>对版本的大版本号更新（比如由3.1.0升级到3.2.0或升级到4.1.0），由于大版本号一般在增加功能、架构变化时产生，对此类升级需要严格测试，并由版本更新提出者提供详细的测试说明，在经过架构小组讨论审批备案后允许升级。</li><li>不允许使用通过获取第三方包的源代码并修改后，自行编译的开发包。</li></ol><h2 id=删除标准>删除标准</h2><p>在项目的开发和维护期，因为项目的变化，可能对原来使用的第三方包不再需要的情况或其他原因，会存在对已使用包的删除问题，需要按下列原则考虑。</p><ol><li><p>使用策略发生变更，导致不再适用于项目</p><p>对于第三方包，在使用策略上发生变化，比如由开源转为闭源、不再维护、由免费改为收费等等情况下，将不再适用于项目中，此时变更可有架构小组提出，并商议审批并备案后，允许删除。此时相应的项目代码，在删除后影响的代码将需要修改测试，以适应删除开发包后的变化。</p></li><li><p>项目因调整，不再需要该第三方包</p><p>对于项目不再需要的开发包，由项目小组提出，并交由架构小组讨论审批备案后允许删除，但需要保证删除该开发包后，其项目代码不受影响。</p></li></ol><h2 id=新增标准>新增标准</h2><p>因项目开发需要，存在新增第三方开发包的需要，对于这些新增包的需求，要严格检测是否与已使用的开发包冲突等多方面的考虑，需要遵循列原则标准。</p><ol><li>对提出需要增加开发包的项目组，需要提供新增包的名称、版本以及可通过Maven获取的仓库点。</li><li>对新增的开发包，需要提供详细的介绍说明，可通过介绍会的方式，引入开发包的原因、测试报告、使用样例、以及在项目中的使用原因等。</li><li>引入新的开发包后，需要对项目已有的开发包是否存在冲突以及是否导致项目产生不稳定因数，都需要以报告会的方式提供，并在提交架构小组审批时，提交这部分文档。</li><li>在项目组成员一致认可该开发包的引入后，提交架构小组审批并备案后，允许新增。</li></ol><h2 id=审批流程>审批流程</h2><p>对于第三方开发包的调整，需要提出人、项目组、架构组三方面的共同确认，其审批流程如下：</p><p><a data-fancybox=gallery href=../images/chapter5/lib-standard-flow.jpg><img src=../images/chapter5/lib-standard-flow.jpg alt=lib-standard-flow.jpg title=lib-standard-flow.jpg></a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f576067bb623bddf831b63a80c458235>5 - 新技术引入标准</h1><div class=lead>本文介绍新技术引入标准</div><h2 id=新技术评估>新技术评估</h2><p>新技术评估</p></div></main></div></div><script src=/js/jquery.fancybox.min.js></script>
<script src=/js/jquery.min.js></script>
<link rel=stylesheet href=/css/jquery.fancybox.min.css><div class=polaris-footer><span>@ 2022 The PolarisMesh Authors</span>
<span class=high-resolution>|</span>
<span>A Tencent Microservice Project</span>
<a href=https://beian.miit.gov.cn/#/Integrated/index>粤B2-20090059</a><div class=polaris-footer-background></div></div></div><script src=/js/main.min.be25a680a0d95dc8b5d6664622e2134aa894220e2f224ef609e00f633a3a1b32.js integrity="sha256-viWmgKDZXci11mZGIuITSqiUIg4vIk72CeAPYzo6GzI=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>